import{_ as n,p as s,q as a,a1 as t}from"./framework-016e66c7.js";const e={},o=t(`<h1 id="chunk-data" tabindex="-1"><a class="header-anchor" href="#chunk-data" aria-hidden="true">#</a> Chunk Data</h1><h2 id="_1-header-0x19" tabindex="-1"><a class="header-anchor" href="#_1-header-0x19" aria-hidden="true">#</a> 1. Header <code>[..0x19]</code></h2><ul><li>The first two bytes represent a short containing the chunk&#39;s version in hex. So far only <code>12 = Aquatic</code> is known.</li><li>The next 8 bytes represent two integers with the chunk&#39;s X and Z position respectively.</li><li>The last 16 bytes are two longs containing the <code>LastUpdate</code> and <code>InhabitedTime</code> tags.</li></ul><div class="language-diff line-numbers-mode" data-ext="diff"><pre class="language-diff"><code><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  |00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
</span><span class="token prefix unchanged"> </span><span class="token line">  |-----------------------------------------------
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">00|00 0C 00 00 00 01 00 00 00 05 00 00 00 00 00 00
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  |^^^^^ ^^^^^^^^^^^ ^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^
</span><span class="token prefix unchanged"> </span><span class="token line">  |Ver.  Chunk X-Pos Chunk Z-Pos LastUpdate...
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">10|00 00 00 00 00 00 00 00 00 00 ?? ?? ?? ?? ?? ??
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  |^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="token prefix unchanged"> </span><span class="token line">  |...   InhabitedTime
</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-section-header-0x1a-0x4b" tabindex="-1"><a class="header-anchor" href="#_2-section-header-0x1a-0x4b" aria-hidden="true">#</a> 2. Section Header <code>[0x1A..0x4B]</code></h2><blockquote><p><strong>*</strong> &quot;Sections&quot; are vertically-aligned cubes of 16×16×16 blocks (4096), and there are 16 of them in each chunk. Starting from 0 (y0) up to 15 (y255)</p></blockquote><ul><li>The first 0x2 <code>[0x1A..0x1B]</code> bytes define how large the block data is (multiply by <code>0x100</code> to get the actual size)</li><li>The next 0x20 bytes <code>[0x1C..0x3B]</code> contain 16 shorts defining offsets of where sections start called the <code>jump table</code>. If an offset matches the block data length (shown above), then there should be no more sections to parse.</li><li>The next 0x10 bytes <code>[0x3C..0x4B]</code> are the sizes of sections. Multiply by <code>0x100</code> to get the actual size. If a size is <code>0</code>, then there&#39;s probably no more sections to parse. (It is recommended to use the <code>jump table</code> if the whole chunk is loaded into memory for each section and not bother with sections sizes and reading into smaller chunks)</li></ul><h2 id="_3-section-data-0x4c-x-0x4c" tabindex="-1"><a class="header-anchor" href="#_3-section-data-0x4c-x-0x4c" aria-hidden="true">#</a> 3. Section Data <code>[0x4C..(*X+0x4C)]</code></h2><blockquote><p><strong>*</strong> X is defined in the Section Header as the &quot;block data size&quot; (The total length of the all the block data sections) <code>[0x1A..0x1B]</code><strong>†</strong> Y is defined in the Section Header as the &quot;section offset&quot;. Add <code>0x4C</code> to get the actual address in the chunk data. <code>[0x1C..0x3B</code><br><strong>‡</strong> Z is defined in the Section Header as the &quot;section size&quot;. <code>[0x3C..0x4B]</code><br><strong>⁂</strong> Grids are cubes of 4×4×4 blocks (64 blocks), and there are 64 of them per section (64x64 = 4096 blocks per section). They are stored in a 4x4x4 grid of the section. <strong>⸸</strong> The Block ID is the first 12 bits and the Block Data is the last 4 bits.<br><strong>Code:</strong> <code>Byte1 Byte2</code> - <code>Block ID = ((byte2 &lt;&lt; 4) + ((byte1 &amp; 0xF0) &gt;&gt; 4)) &amp; 0x1FF;</code> + <code>Data Value: byte1 &amp; 0xf;</code><br><strong>Example:</strong> <code>0x70 0x05</code> - <code>Block ID: 0x57 (87)</code> + <code>Data Value: 0x0 (0)</code></p></blockquote><p>For each section:</p><ul><li><p>The first 0x80 bytes <code>[†Y..Y+0x7F]</code> is the grid<code>⁂</code> index table. Grid indicies are stored in YZX format. <code>gridIndex = Y† + ((gx * 16) + (gz * 4) + gy)</code></p></li><li><p>The remaining bytes <code>[Y+0x80..(Y+(Z-0x80))]</code> define the &#39;palette&#39; data, storing what blocks are used in the section.</p></li><li><p>Each &quot;grid index&quot; consist of 2 bytes. The first nybble of the second byte defines the grid&#39;s format, which defines how the blocks are stored and how many bits are stored. Nybbles <code>3</code>, <code>0</code>, and <code>1</code> build the offset of where the grid&#39;s palette is stored in that section data. <code>offset = (nybble3 &lt;&lt; 8 | nybble0 &lt;&lt; 4 | nybble1) * 4</code> / <code>format = nybble2</code></p></li><li><p><strong>Example:</strong> <code>0x9C 0x40</code> - <code>Format = 0x4</code> + <code>Offset = 0x270</code></p></li><li><p>How to parse blocks from the format:</p></li></ul><table><thead><tr><th>Format</th><th>Palette Size</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>1 (0x01)</td><td>The entire grid is filled with just one type of block. Block is stored in the grid index itself (<code>byte 0</code> and <code>byte 1</code> make up the block data⸸). Copy <code>byte 0</code> and <code>byte 1</code> into the block data array 128 times (64 times each and alternating)</td></tr><tr><td>E</td><td>128 (0x80)</td><td>The palette for this grid is is 0x80 bytes long and are read straight into the block data array without parsing.</td></tr><tr><td>F</td><td>256 (0x100)</td><td>The format is the same as above and there is an extra 0x80 bytes at the end that are read straight into &quot;Liquid&quot; data without parsing.</td></tr><tr><td>2</td><td>12 (0x0C)</td><td>The grid contains only 2 block types. The first 2 shorts of the palette are the blocks. The last 8 bytes define bits that store the block&#39;s positions. (1 bit per block)</td></tr><tr><td>3</td><td>20 (0x14)</td><td>The format is the same as above and there is an extra 8 bytes at the end that point to the grid and are read into &quot;Liquid&quot; data. (1 bit per block)</td></tr><tr><td>4</td><td>24 (0x18)</td><td>The grid contains up to 4 block types. The first 4 shorts of the palette are the blocks. The last 16 bytes define bits that store the block&#39;s positions. (2 bits per block)</td></tr><tr><td>5</td><td>40 (0x28)</td><td>The format is the same as above and there is an extra 16 bytes at the end that point to the grid and are read into &quot;Liquid&quot; data. (2 bits per block)</td></tr><tr><td>6</td><td>40 (0x28)</td><td>The grid contains up to 8 block types. The first 8 shorts of the palette are the blocks. The last 28 bytes define bits that store the block&#39;s positions. (3 bits per block)</td></tr><tr><td>7</td><td>64 (0x40)</td><td>The format is the same as above and there is an extra 28 bytes at the end that point to the grid and are read into &quot;Liquid&quot; data. (3 bits per block)</td></tr><tr><td>8</td><td>64 (0x40)</td><td>The grid contains up to 16 block types. The first 16 shorts of the palette are the blocks. The last 32 bytes define bits that store the block&#39;s positions. (4 bits per block)</td></tr><tr><td>9</td><td>96 (0x60)</td><td>The format is the same as above and there is an extra 32 bytes at the end that point to the grid and are read into &quot;Liquid&quot; data. (4 bits per block)</td></tr></tbody></table><ul><li><p>If there are less blocks in the grid than the limit then it the rest will be filled with <code>0xFF</code>.</p></li><li><p>The extra pointers that gets parsed into &quot;Liquid&quot; data work the same way as the pointers to the blocks.</p></li><li><p>The code below shows how to get the block positions from the data (the previous explanation was incorrect):</p></li></ul><p>Here is working code for parsing these sub chunks (without extra &quot;Liquid&quot; data):</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span>size_t BitsPerBlock<span class="token operator">&gt;</span>
    <span class="token keyword">bool</span> <span class="token function">Parse</span><span class="token punctuation">(</span><span class="token keyword">uint8_t</span> <span class="token keyword">const</span><span class="token operator">*</span> buffer<span class="token punctuation">,</span> <span class="token keyword">uint16_t</span><span class="token operator">*</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> BitsPerBlock<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">uint16_t</span><span class="token operator">&gt;</span> <span class="token function">palette</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">copy_n</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> size<span class="token punctuation">,</span> palette<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">uint8_t</span> v<span class="token punctuation">[</span>BitsPerBlock<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> BitsPerBlock<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                v<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> buffer<span class="token punctuation">[</span>size <span class="token operator">+</span> i <span class="token operator">+</span> j <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">uint8_t</span> mask <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint8_t</span><span class="token punctuation">)</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> j<span class="token punctuation">;</span>
                <span class="token keyword">uint16_t</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> BitsPerBlock<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    idx <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token number">7</span> <span class="token operator">-</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> k<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&gt;=</span> size<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>unlikely<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">int</span> gridIndex <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">8</span> <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> paletteIndex <span class="token operator">=</span> idx <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
                grid<span class="token punctuation">[</span>gridIndex<span class="token punctuation">]</span> <span class="token operator">=</span> palette<span class="token punctuation">[</span>paletteIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
                grid<span class="token punctuation">[</span>gridIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> palette<span class="token punctuation">[</span>paletteIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Here is working code for parsing these sub chunks (with extra &quot;Liquid&quot; data):</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span>size_t BitsPerBlock<span class="token operator">&gt;</span>
    <span class="token keyword">bool</span> <span class="token function">ParseWithLayers</span><span class="token punctuation">(</span><span class="token keyword">uint8_t</span> <span class="token keyword">const</span><span class="token operator">*</span> buffer<span class="token punctuation">,</span> <span class="token keyword">uint16_t</span><span class="token operator">*</span> grid<span class="token punctuation">,</span> <span class="token keyword">uint16_t</span><span class="token operator">*</span> submergedGrid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> BitsPerBlock<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">uint16_t</span><span class="token operator">&gt;</span> <span class="token function">palette</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">copy_n</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> size<span class="token punctuation">,</span> palette<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">uint8_t</span> v<span class="token punctuation">[</span>BitsPerBlock<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">uint8_t</span> vSubmerged<span class="token punctuation">[</span>BitsPerBlock<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> BitsPerBlock<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> offset <span class="token operator">=</span> size <span class="token operator">+</span> i <span class="token operator">+</span> j <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">;</span>
                v<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> buffer<span class="token punctuation">[</span>offset<span class="token punctuation">]</span><span class="token punctuation">;</span>
                vSubmerged<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> buffer<span class="token punctuation">[</span>offset <span class="token operator">+</span> BitsPerBlock <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">uint8_t</span> mask <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint8_t</span><span class="token punctuation">)</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> j<span class="token punctuation">;</span>
                <span class="token keyword">uint16_t</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">uint16_t</span> idxSubmerged <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> BitsPerBlock<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    idx <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token number">7</span> <span class="token operator">-</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> k<span class="token punctuation">;</span>
                    idxSubmerged <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>vSubmerged<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token number">7</span> <span class="token operator">-</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> k<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&gt;=</span> size <span class="token operator">||</span> idxSubmerged <span class="token operator">&gt;=</span> size<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>unlikely<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">int</span> gridIndex <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">8</span> <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> paletteIndex <span class="token operator">=</span> idx <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> paletteIndexSubmerged <span class="token operator">=</span> idxSubmerged <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
                grid<span class="token punctuation">[</span>gridIndex<span class="token punctuation">]</span> <span class="token operator">=</span> palette<span class="token punctuation">[</span>paletteIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
                grid<span class="token punctuation">[</span>gridIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> palette<span class="token punctuation">[</span>paletteIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                submergedGrid<span class="token punctuation">[</span>gridIndex<span class="token punctuation">]</span> <span class="token operator">=</span> palette<span class="token punctuation">[</span>paletteIndexSubmerged<span class="token punctuation">]</span><span class="token punctuation">;</span>
                submergedGrid<span class="token punctuation">[</span>gridIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> palette<span class="token punctuation">[</span>paletteIndexSubmerged <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-block-light-sky-light-x" tabindex="-1"><a class="header-anchor" href="#_4-block-light-sky-light-x" aria-hidden="true">#</a> 4. Block Light &amp; Sky Light <code>[X..??]</code></h2><blockquote><p><strong>*</strong> X is the total length of the all the block data sections, as shown in the <strong>Section Data</strong>. Add <code>0x4C</code> to get the starting offset. <code>[0x1A..0x1B]</code></p></blockquote><ul><li><p>Skylight and Blocklight are nybble arrays of 0x8000 bytes stored in XZY format</p></li><li><p>There are 4 different &quot;sections&quot; of light, the first 2 are the SkyLight, and the last 2 being the BlockLight.</p></li></ul><table><thead><tr><th>For each section</th></tr></thead><tbody><tr><td>The first 4 bytes (*int) times by 128 plus 128 defines the length of that section <code>(*int + 1) * 0x80</code> or <code>*int * 0x80 + 0x80</code></td></tr><tr><td>The first 0x80 bytes is the header for the data</td></tr></tbody></table><table><thead><tr><th>For each byte in the header</th></tr></thead><tbody><tr><td>If the byte is <code>0x80</code> then fill 128 bytes of Skylight/Blocklight with <code>0x00</code></td></tr><tr><td>If the byte is <code>0x81</code> then fill 128 bytes of Skylight/Blocklight with <code>0xFF</code></td></tr><tr><td>If the byte is not <code>0x80</code> or <code>0x81</code>, then read 128 bytes of data with offset of <code>byte value * 0x80 + 0x80</code> from the section into Skylight/Blocklight data. (Note that the <code>+0x80</code> is there because the header is 128 bytes long)</td></tr></tbody></table><h2 id="_5-height-map-terrainpopulatedflags-biomes-0x-0x-0x202" tabindex="-1"><a class="header-anchor" href="#_5-height-map-terrainpopulatedflags-biomes-0x-0x-0x202" aria-hidden="true">#</a> 5. Height Map, TerrainPopulatedFlags, &amp; Biomes <code>[0x??..(0x??+0x202)]</code></h2><ul><li>The first 0x100 bytes store the HeightMap byte array.</li><li>The next 0x2 bytes store the short <code>TerrainPopulatedFlags</code>.</li><li>The last 0x100 bytes store the Biomes byte array.</li></ul><h2 id="_6-raw-nbt-data-0x" tabindex="-1"><a class="header-anchor" href="#_6-raw-nbt-data-0x" aria-hidden="true">#</a> 6. Raw NBT Data <code>[0x??..]</code></h2><ul><li>The rest of the file contains raw NBT data after all the other data.</li></ul>`,26),p=[o];function c(i,l){return s(),a("div",null,p)}const u=n(e,[["render",c],["__file","index.html.vue"]]);export{u as default};
